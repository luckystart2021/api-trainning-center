// Code generated by SQLBoiler 3.7.1 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// Seo is an object representing the database table.
type Seo struct {
	ID                 int    `boil:"id" json:"id" toml:"id" yaml:"id"`
	Description        string `boil:"description" json:"description" toml:"description" yaml:"description"`
	Keywords           string `boil:"keywords" json:"keywords" toml:"keywords" yaml:"keywords"`
	FBAppID            string `boil:"fb_app_id" json:"fb_app_id" toml:"fb_app_id" yaml:"fb_app_id"`
	OgTitle            string `boil:"og_title" json:"og_title" toml:"og_title" yaml:"og_title"`
	OgURL              string `boil:"og_url" json:"og_url" toml:"og_url" yaml:"og_url"`
	OgImage            string `boil:"og_image" json:"og_image" toml:"og_image" yaml:"og_image"`
	OgDescription      string `boil:"og_description" json:"og_description" toml:"og_description" yaml:"og_description"`
	OgSiteName         string `boil:"og_site_name" json:"og_site_name" toml:"og_site_name" yaml:"og_site_name"`
	OgSeeAlso          string `boil:"og_see_also" json:"og_see_also" toml:"og_see_also" yaml:"og_see_also"`
	OgLocale           string `boil:"og_locale" json:"og_locale" toml:"og_locale" yaml:"og_locale"`
	ArticleAuthor      string `boil:"article_author" json:"article_author" toml:"article_author" yaml:"article_author"`
	TwitterCard        string `boil:"twitter_card" json:"twitter_card" toml:"twitter_card" yaml:"twitter_card"`
	TwitterURL         string `boil:"twitter_url" json:"twitter_url" toml:"twitter_url" yaml:"twitter_url"`
	TwitterTitle       string `boil:"twitter_title" json:"twitter_title" toml:"twitter_title" yaml:"twitter_title"`
	TwitterDescription string `boil:"twitter_description" json:"twitter_description" toml:"twitter_description" yaml:"twitter_description"`
	TwitterImage       string `boil:"twitter_image" json:"twitter_image" toml:"twitter_image" yaml:"twitter_image"`
	Author             string `boil:"author" json:"author" toml:"author" yaml:"author"`
	Generator          string `boil:"generator" json:"generator" toml:"generator" yaml:"generator"`
	Copyright          string `boil:"copyright" json:"copyright" toml:"copyright" yaml:"copyright"`

	R *seoR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L seoL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SeoColumns = struct {
	ID                 string
	Description        string
	Keywords           string
	FBAppID            string
	OgTitle            string
	OgURL              string
	OgImage            string
	OgDescription      string
	OgSiteName         string
	OgSeeAlso          string
	OgLocale           string
	ArticleAuthor      string
	TwitterCard        string
	TwitterURL         string
	TwitterTitle       string
	TwitterDescription string
	TwitterImage       string
	Author             string
	Generator          string
	Copyright          string
}{
	ID:                 "id",
	Description:        "description",
	Keywords:           "keywords",
	FBAppID:            "fb_app_id",
	OgTitle:            "og_title",
	OgURL:              "og_url",
	OgImage:            "og_image",
	OgDescription:      "og_description",
	OgSiteName:         "og_site_name",
	OgSeeAlso:          "og_see_also",
	OgLocale:           "og_locale",
	ArticleAuthor:      "article_author",
	TwitterCard:        "twitter_card",
	TwitterURL:         "twitter_url",
	TwitterTitle:       "twitter_title",
	TwitterDescription: "twitter_description",
	TwitterImage:       "twitter_image",
	Author:             "author",
	Generator:          "generator",
	Copyright:          "copyright",
}

// Generated where

var SeoWhere = struct {
	ID                 whereHelperint
	Description        whereHelperstring
	Keywords           whereHelperstring
	FBAppID            whereHelperstring
	OgTitle            whereHelperstring
	OgURL              whereHelperstring
	OgImage            whereHelperstring
	OgDescription      whereHelperstring
	OgSiteName         whereHelperstring
	OgSeeAlso          whereHelperstring
	OgLocale           whereHelperstring
	ArticleAuthor      whereHelperstring
	TwitterCard        whereHelperstring
	TwitterURL         whereHelperstring
	TwitterTitle       whereHelperstring
	TwitterDescription whereHelperstring
	TwitterImage       whereHelperstring
	Author             whereHelperstring
	Generator          whereHelperstring
	Copyright          whereHelperstring
}{
	ID:                 whereHelperint{field: "\"seo\".\"id\""},
	Description:        whereHelperstring{field: "\"seo\".\"description\""},
	Keywords:           whereHelperstring{field: "\"seo\".\"keywords\""},
	FBAppID:            whereHelperstring{field: "\"seo\".\"fb_app_id\""},
	OgTitle:            whereHelperstring{field: "\"seo\".\"og_title\""},
	OgURL:              whereHelperstring{field: "\"seo\".\"og_url\""},
	OgImage:            whereHelperstring{field: "\"seo\".\"og_image\""},
	OgDescription:      whereHelperstring{field: "\"seo\".\"og_description\""},
	OgSiteName:         whereHelperstring{field: "\"seo\".\"og_site_name\""},
	OgSeeAlso:          whereHelperstring{field: "\"seo\".\"og_see_also\""},
	OgLocale:           whereHelperstring{field: "\"seo\".\"og_locale\""},
	ArticleAuthor:      whereHelperstring{field: "\"seo\".\"article_author\""},
	TwitterCard:        whereHelperstring{field: "\"seo\".\"twitter_card\""},
	TwitterURL:         whereHelperstring{field: "\"seo\".\"twitter_url\""},
	TwitterTitle:       whereHelperstring{field: "\"seo\".\"twitter_title\""},
	TwitterDescription: whereHelperstring{field: "\"seo\".\"twitter_description\""},
	TwitterImage:       whereHelperstring{field: "\"seo\".\"twitter_image\""},
	Author:             whereHelperstring{field: "\"seo\".\"author\""},
	Generator:          whereHelperstring{field: "\"seo\".\"generator\""},
	Copyright:          whereHelperstring{field: "\"seo\".\"copyright\""},
}

// SeoRels is where relationship names are stored.
var SeoRels = struct {
}{}

// seoR is where relationships are stored.
type seoR struct {
}

// NewStruct creates a new relationship struct
func (*seoR) NewStruct() *seoR {
	return &seoR{}
}

// seoL is where Load methods for each relationship are stored.
type seoL struct{}

var (
	seoAllColumns            = []string{"id", "description", "keywords", "fb_app_id", "og_title", "og_url", "og_image", "og_description", "og_site_name", "og_see_also", "og_locale", "article_author", "twitter_card", "twitter_url", "twitter_title", "twitter_description", "twitter_image", "author", "generator", "copyright"}
	seoColumnsWithoutDefault = []string{"description", "keywords", "fb_app_id", "og_title", "og_url", "og_image", "og_description", "og_site_name", "og_see_also", "og_locale", "article_author", "twitter_card", "twitter_url", "twitter_title", "twitter_description", "twitter_image", "author", "generator", "copyright"}
	seoColumnsWithDefault    = []string{"id"}
	seoPrimaryKeyColumns     = []string{"id"}
)

type (
	// SeoSlice is an alias for a slice of pointers to Seo.
	// This should generally be used opposed to []Seo.
	SeoSlice []*Seo
	// SeoHook is the signature for custom Seo hook methods
	SeoHook func(context.Context, boil.ContextExecutor, *Seo) error

	seoQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	seoType                 = reflect.TypeOf(&Seo{})
	seoMapping              = queries.MakeStructMapping(seoType)
	seoPrimaryKeyMapping, _ = queries.BindMapping(seoType, seoMapping, seoPrimaryKeyColumns)
	seoInsertCacheMut       sync.RWMutex
	seoInsertCache          = make(map[string]insertCache)
	seoUpdateCacheMut       sync.RWMutex
	seoUpdateCache          = make(map[string]updateCache)
	seoUpsertCacheMut       sync.RWMutex
	seoUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var seoBeforeInsertHooks []SeoHook
var seoBeforeUpdateHooks []SeoHook
var seoBeforeDeleteHooks []SeoHook
var seoBeforeUpsertHooks []SeoHook

var seoAfterInsertHooks []SeoHook
var seoAfterSelectHooks []SeoHook
var seoAfterUpdateHooks []SeoHook
var seoAfterDeleteHooks []SeoHook
var seoAfterUpsertHooks []SeoHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Seo) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range seoBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Seo) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range seoBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Seo) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range seoBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Seo) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range seoBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Seo) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range seoAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Seo) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range seoAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Seo) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range seoAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Seo) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range seoAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Seo) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range seoAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddSeoHook registers your hook function for all future operations.
func AddSeoHook(hookPoint boil.HookPoint, seoHook SeoHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		seoBeforeInsertHooks = append(seoBeforeInsertHooks, seoHook)
	case boil.BeforeUpdateHook:
		seoBeforeUpdateHooks = append(seoBeforeUpdateHooks, seoHook)
	case boil.BeforeDeleteHook:
		seoBeforeDeleteHooks = append(seoBeforeDeleteHooks, seoHook)
	case boil.BeforeUpsertHook:
		seoBeforeUpsertHooks = append(seoBeforeUpsertHooks, seoHook)
	case boil.AfterInsertHook:
		seoAfterInsertHooks = append(seoAfterInsertHooks, seoHook)
	case boil.AfterSelectHook:
		seoAfterSelectHooks = append(seoAfterSelectHooks, seoHook)
	case boil.AfterUpdateHook:
		seoAfterUpdateHooks = append(seoAfterUpdateHooks, seoHook)
	case boil.AfterDeleteHook:
		seoAfterDeleteHooks = append(seoAfterDeleteHooks, seoHook)
	case boil.AfterUpsertHook:
		seoAfterUpsertHooks = append(seoAfterUpsertHooks, seoHook)
	}
}

// One returns a single seo record from the query.
func (q seoQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Seo, error) {
	o := &Seo{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for seo")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Seo records from the query.
func (q seoQuery) All(ctx context.Context, exec boil.ContextExecutor) (SeoSlice, error) {
	var o []*Seo

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Seo slice")
	}

	if len(seoAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Seo records in the query.
func (q seoQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count seo rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q seoQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if seo exists")
	}

	return count > 0, nil
}

// Seos retrieves all the records using an executor.
func Seos(mods ...qm.QueryMod) seoQuery {
	mods = append(mods, qm.From("\"seo\""))
	return seoQuery{NewQuery(mods...)}
}

// FindSeo retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSeo(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*Seo, error) {
	seoObj := &Seo{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"seo\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, seoObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from seo")
	}

	return seoObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Seo) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no seo provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(seoColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	seoInsertCacheMut.RLock()
	cache, cached := seoInsertCache[key]
	seoInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			seoAllColumns,
			seoColumnsWithDefault,
			seoColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(seoType, seoMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(seoType, seoMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"seo\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"seo\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into seo")
	}

	if !cached {
		seoInsertCacheMut.Lock()
		seoInsertCache[key] = cache
		seoInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Seo.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Seo) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	seoUpdateCacheMut.RLock()
	cache, cached := seoUpdateCache[key]
	seoUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			seoAllColumns,
			seoPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update seo, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"seo\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, seoPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(seoType, seoMapping, append(wl, seoPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update seo row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for seo")
	}

	if !cached {
		seoUpdateCacheMut.Lock()
		seoUpdateCache[key] = cache
		seoUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q seoQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for seo")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for seo")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SeoSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), seoPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"seo\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, seoPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in seo slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all seo")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Seo) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no seo provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(seoColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	seoUpsertCacheMut.RLock()
	cache, cached := seoUpsertCache[key]
	seoUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			seoAllColumns,
			seoColumnsWithDefault,
			seoColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			seoAllColumns,
			seoPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert seo, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(seoPrimaryKeyColumns))
			copy(conflict, seoPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"seo\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(seoType, seoMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(seoType, seoMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert seo")
	}

	if !cached {
		seoUpsertCacheMut.Lock()
		seoUpsertCache[key] = cache
		seoUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Seo record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Seo) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Seo provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), seoPrimaryKeyMapping)
	sql := "DELETE FROM \"seo\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from seo")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for seo")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q seoQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no seoQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from seo")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for seo")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SeoSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(seoBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), seoPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"seo\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, seoPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from seo slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for seo")
	}

	if len(seoAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Seo) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSeo(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SeoSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SeoSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), seoPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"seo\".* FROM \"seo\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, seoPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in SeoSlice")
	}

	*o = slice

	return nil
}

// SeoExists checks if the Seo row exists.
func SeoExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"seo\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if seo exists")
	}

	return exists, nil
}
